{
  "api/RetroEditor.Plugins.ChangedEventHandler.html": {
    "href": "api/RetroEditor.Plugins.ChangedEventHandler.html",
    "title": "Delegate ChangedEventHandler | RetroEditor",
    "keywords": "Delegate ChangedEventHandler Namespace RetroEditor.Plugins Assembly RetroEditor.dll Delegate for a changed event. Would be called if a value changes in a widget that supports it public delegate void ChangedEventHandler()"
  },
  "api/RetroEditor.Plugins.IBitmapImage.html": {
    "href": "api/RetroEditor.Plugins.IBitmapImage.html",
    "title": "Interface IBitmapImage | RetroEditor",
    "keywords": "Interface IBitmapImage Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a bitmap image - used with the BitmapWidget class public interface IBitmapImage Properties Height Height of the image in pixels uint Height { get; } Property Value uint Palette Palette for the image IBitmapPalette Palette { get; } Property Value IBitmapPalette PixelHeight Height of a pixel in pixels uint PixelHeight { get; } Property Value uint PixelWidth Width of a pixel in pixels uint PixelWidth { get; } Property Value uint Width Width of the image in pixels uint Width { get; } Property Value uint Methods GetImageData(float) Image data as a flat array of palette indices ReadOnlySpan<uint> GetImageData(float seconds) Parameters seconds float Number of seconds since startup Returns ReadOnlySpan<uint> pixel index array SetPixel(uint, uint, uint) Set a pixel in the image Is called when a pixel is set in the editor, this should be used to make the change in the games memory void SetPixel(uint x, uint y, uint paletteIndex) Parameters x uint y uint paletteIndex uint"
  },
  "api/RetroEditor.Plugins.IBitmapPalette.html": {
    "href": "api/RetroEditor.Plugins.IBitmapPalette.html",
    "title": "Interface IBitmapPalette | RetroEditor",
    "keywords": "Interface IBitmapPalette Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a palette - used with the PaletteWidget class public interface IBitmapPalette Properties ColoursPerRow Colours to display per row uint ColoursPerRow { get; } Property Value uint Height Height of each colour in pixels uint Height { get; } Property Value uint SelectedColour Current chosen palette index int SelectedColour { get; set; } Property Value int Width Width of each colour in pixels uint Width { get; } Property Value uint Methods GetPalette() Get the palette ReadOnlySpan<Pixel> GetPalette() Returns ReadOnlySpan<Pixel> Array of colours"
  },
  "api/RetroEditor.Plugins.IEditor.html": {
    "href": "api/RetroEditor.Plugins.IEditor.html",
    "title": "Interface IEditor | RetroEditor",
    "keywords": "Interface IEditor Namespace RetroEditor.Plugins Assembly RetroEditor.dll Editor interface - used to interact with the editor public interface IEditor Methods Log(LogType, string) Write a message to the editor log void Log(LogType type, string message) Parameters type LogType LogType severity of message message string message Remarks The message will appear in a section specific to the plugin OpenUserWindow(string, IUserWindow) Create a new window in the editor void OpenUserWindow(string name, IUserWindow window) Parameters name string Name of the window window IUserWindow Objet implementing IUserWindow"
  },
  "api/RetroEditor.Plugins.IImage.html": {
    "href": "api/RetroEditor.Plugins.IImage.html",
    "title": "Interface IImage | RetroEditor",
    "keywords": "Interface IImage Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for an image - used by the ImageView class public interface IImage Properties Height Height of the image in pixels uint Height { get; } Property Value uint ScaleX Amount to scale image by in X float ScaleX { get; } Property Value float ScaleY Amount to scale image by in Y float ScaleY { get; } Property Value float Width Width of the image in pixels uint Width { get; } Property Value uint Methods GetImageData(float) Get the image data for the current time ReadOnlySpan<Pixel> GetImageData(float seconds) Parameters seconds float Time since editor started Returns ReadOnlySpan<Pixel> Flat array of Pixel values representing the image"
  },
  "api/RetroEditor.Plugins.ILayer.html": {
    "href": "api/RetroEditor.Plugins.ILayer.html",
    "title": "Interface ILayer | RetroEditor",
    "keywords": "Interface ILayer Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a layer in a tile map public interface ILayer Properties Height Height of the layer in tiles uint Height { get; } Property Value uint Width Width of the layer in tiles uint Width { get; } Property Value uint Methods GetMapData() Get the map data for the layer ReadOnlySpan<uint> GetMapData() Returns ReadOnlySpan<uint> Flat array of tile indices SetTile(uint, uint, uint) Called when a tile is set in the editor, this should be used to make the change in the games memory void SetTile(uint x, uint y, uint tile) Parameters x uint x offset of modified tile in tiles y uint y offset of modified tile in tiles tile uint tile index"
  },
  "api/RetroEditor.Plugins.IMemoryAccess.html": {
    "href": "api/RetroEditor.Plugins.IMemoryAccess.html",
    "title": "Interface IMemoryAccess | RetroEditor",
    "keywords": "Interface IMemoryAccess Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for accessing memory public interface IMemoryAccess Properties Endian Memory Endian of the system MemoryEndian Endian { get; } Property Value MemoryEndian Endianess of memory RomSize Size of the loaded rom (only applies to cartridge based systems) int RomSize { get; } Property Value int Size of rom in bytes Methods FetchMachineOrder16(int, ReadOnlySpan<byte>) Given a byte array and offset, returns a 16 bit value in machine order ushort FetchMachineOrder16(int offset, ReadOnlySpan<byte> bytes) Parameters offset int offset in bytes bytes ReadOnlySpan<byte> array of bytes Returns ushort 16 bit value from requested offset FetchMachineOrder32(int, ReadOnlySpan<byte>) Given a byte array and offset, returns a 32 bit value in machine order uint FetchMachineOrder32(int offset, ReadOnlySpan<byte> bytes) Parameters offset int offset in bytes bytes ReadOnlySpan<byte> array of bytes Returns uint 32 bit value from requested offset FetchOppositeMachineOrder16(int, ReadOnlySpan<byte>) Given a byte array and offset, returns a 16 bit value in opposite machine order ushort FetchOppositeMachineOrder16(int offset, ReadOnlySpan<byte> bytes) Parameters offset int offset in bytes bytes ReadOnlySpan<byte> array of bytes Returns ushort 16 bit value from requested offset FetchOppositeMachineOrder32(int, ReadOnlySpan<byte>) Given a byte array and offset, returns a 32 bit value in opposite machine order uint FetchOppositeMachineOrder32(int offset, ReadOnlySpan<byte> bytes) Parameters offset int offset in bytes bytes ReadOnlySpan<byte> array of bytes Returns uint 32 bit value from requested offset ReadBytes(ReadKind, uint, uint) Read a number of bytes from the specified memory area ReadOnlySpan<byte> ReadBytes(ReadKind kind, uint address, uint length) Parameters kind ReadKind Memory kind address uint Address of first byte length uint Number of bytes to retrieve Returns ReadOnlySpan<byte> WriteBytes(WriteKind, uint, ReadOnlySpan<byte>) Write a number of bytes to the specified memory area void WriteBytes(WriteKind kind, uint address, ReadOnlySpan<byte> bytes) Parameters kind WriteKind Memory kind address uint Address to write to bytes ReadOnlySpan<byte> Bytes to write to address WriteMachineOrder16(int, Span<byte>, ushort) Given a byte array and offset, writes a 16bit value in machine order void WriteMachineOrder16(int offset, Span<byte> bytes, ushort value) Parameters offset int offset in bytes bytes Span<byte> array of bytes value ushort value to write WriteMachineOrder32(int, Span<byte>, uint) Given a byte array and offset, writes a 32bit value in machine order void WriteMachineOrder32(int offset, Span<byte> bytes, uint value) Parameters offset int offset in bytes bytes Span<byte> array of bytes value uint value to write WriteOppositeMachineOrder16(int, Span<byte>, ushort) Given a byte array and offset, writes a 16bit value in opposite machine order void WriteOppositeMachineOrder16(int offset, Span<byte> bytes, ushort value) Parameters offset int offset in bytes bytes Span<byte> array of bytes value ushort value to write WriteOppositeMachineOrder32(int, Span<byte>, uint) Given a byte array and offset, writes a 32bit value in opposite machine order void WriteOppositeMachineOrder32(int offset, Span<byte> bytes, uint value) Parameters offset int offset in bytes bytes Span<byte> array of bytes value uint value to write"
  },
  "api/RetroEditor.Plugins.IMenu.html": {
    "href": "api/RetroEditor.Plugins.IMenu.html",
    "title": "Interface IMenu | RetroEditor",
    "keywords": "Interface IMenu Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for creating menus public interface IMenu Methods AddItem(IMenuItem, string) Add a menu parented to another menu item. Represents a new submenu. IMenuItem AddItem(IMenuItem parent, string name) Parameters parent IMenuItem Parent to attach new item to name string Name of the menu item Returns IMenuItem object representing the new item AddItem(IMenuItem, string, MenuEventHandler) Add an interactable menu item to the parent menu item IMenuItem AddItem(IMenuItem parent, string name, MenuEventHandler handler) Parameters parent IMenuItem Parent to attach new item to name string Name of the menu item handler MenuEventHandler Handler for the menu item Returns IMenuItem object representing the new item AddItem(string) Add a menu item to the root of the plugins menu. Represents a new submenu. IMenuItem AddItem(string name) Parameters name string Name of the menu item Returns IMenuItem object representing the new item AddItem(string, MenuEventHandler) Add an interactable menu item to the root of the plugins menu. IMenuItem AddItem(string name, MenuEventHandler handler) Parameters name string Name of the menu item handler MenuEventHandler Handler for the menu item Returns IMenuItem object representing the new item"
  },
  "api/RetroEditor.Plugins.IMenuItem.html": {
    "href": "api/RetroEditor.Plugins.IMenuItem.html",
    "title": "Interface IMenuItem | RetroEditor",
    "keywords": "Interface IMenuItem Namespace RetroEditor.Plugins Assembly RetroEditor.dll Represents a menu item public interface IMenuItem Properties Enabled Enable or disable the menu item bool Enabled { get; set; } Property Value bool Handler Handler event for the menu item MenuEventHandler? Handler { get; set; } Property Value MenuEventHandler Name Name of the menu item to display string Name { get; set; } Property Value string"
  },
  "api/RetroEditor.Plugins.IMenuProvider.html": {
    "href": "api/RetroEditor.Plugins.IMenuProvider.html",
    "title": "Interface IMenuProvider | RetroEditor",
    "keywords": "Interface IMenuProvider Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for providing menus Allows a plugin to provide a set of menus to the editor public interface IMenuProvider Methods ConfigureMenu(IMemoryAccess, IMenu) Configure the menu for the editor void ConfigureMenu(IMemoryAccess rom, IMenu menu) Parameters rom IMemoryAccess Memory access interface menu IMenu Menu interface"
  },
  "api/RetroEditor.Plugins.IPlayerControls.html": {
    "href": "api/RetroEditor.Plugins.IPlayerControls.html",
    "title": "Interface IPlayerControls | RetroEditor",
    "keywords": "Interface IPlayerControls Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for libretro emulator player public interface IPlayerControls Methods Reset() Reset the emulator void Reset()"
  },
  "api/RetroEditor.Plugins.IPlayerWindowExtension.html": {
    "href": "api/RetroEditor.Plugins.IPlayerWindowExtension.html",
    "title": "Interface IPlayerWindowExtension | RetroEditor",
    "keywords": "Interface IPlayerWindowExtension Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface to allow a plugin to add widgets to the player window. public interface IPlayerWindowExtension Methods ConfigureWidgets(IMemoryAccess, IWidget, IPlayerControls) Called when the player window is opened, to allow the plugin to define its widgets. void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) Parameters rom IMemoryAccess memory interface widget IWidget widget interface playerControls IPlayerControls player controls interface"
  },
  "api/RetroEditor.Plugins.IRetroPlugin.html": {
    "href": "api/RetroEditor.Plugins.IRetroPlugin.html",
    "title": "Interface IRetroPlugin | RetroEditor",
    "keywords": "Interface IRetroPlugin Namespace RetroEditor.Plugins Assembly RetroEditor.dll The primary interface to implement when developing a new plugin public interface IRetroPlugin Properties Name Name of the plugin public static abstract string Name { get; } Property Value string RequiresAutoLoad Does this game require loading to be skipped For instance games that are loaded from tape, should return true here and then implement the AutoLoadCondition method to determine when the loading is complete bool RequiresAutoLoad { get; } Property Value bool RomPluginName Name of the rom plugin required for this game string RomPluginName { get; } Property Value string Methods AutoLoadCondition(IMemoryAccess) If auto load is required, this method should determine when the loading is complete bool AutoLoadCondition(IMemoryAccess romAccess) Parameters romAccess IMemoryAccess memory interface Returns bool true if condition met, else false CanHandle(string) This is called when a game is opened, to determine which plugin can handle it bool CanHandle(string path) Parameters path string Path of file to check Returns bool Remarks At present this cannot be used to determine the specific copy of the game that was loaded, as the plugin is recreated after this call Export(IMemoryAccess) This is called when an export is required, it should return a save object that can be used to generate the final modded game ISave Export(IMemoryAccess romAcess) Parameters romAcess IMemoryAccess memory interface Returns ISave Saveable object SetupGameTemporaryPatches(IMemoryAccess) This is called to allow initial patches to be applied to the game being editing, for instance to allow cheats to be applied, or to skip loading screens void SetupGameTemporaryPatches(IMemoryAccess romAccess) Parameters romAccess IMemoryAccess memory interface"
  },
  "api/RetroEditor.Plugins.ISave.html": {
    "href": "api/RetroEditor.Plugins.ISave.html",
    "title": "Interface ISave | RetroEditor",
    "keywords": "Interface ISave Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for saving data, intended to be used to generate the final modded game At present only implemented by ZXSpectrumTape public interface ISave Methods Save(string) Save the data to a file void Save(string path) Parameters path string path to save file"
  },
  "api/RetroEditor.Plugins.ISystemPlugin.html": {
    "href": "api/RetroEditor.Plugins.ISystemPlugin.html",
    "title": "Interface ISystemPlugin | RetroEditor",
    "keywords": "Interface ISystemPlugin Namespace RetroEditor.Plugins Assembly RetroEditor.dll Defines a system plugin (e.g. Megadrive, NES, etc) public interface ISystemPlugin Properties Endian Memory Endianess of the system MemoryEndian Endian { get; } Property Value MemoryEndian LibRetroPluginName Name of the libretro core plugin - used to retrieve and load the correct core string LibRetroPluginName { get; } Property Value string Name Name of the system, used in IRetroPlugin to determine which system is needed for the particular game public static abstract string Name { get; } Property Value string RequiresReload Whether the system requires a reload of the core when the rom data is changed. In general cartridge based systems require a reload bool RequiresReload { get; } Property Value bool Methods ChecksumCalculation(IMemoryAccess, out int) Checksum calculation for the system - used to recompute the checksum for systems that require it ReadOnlySpan<byte> ChecksumCalculation(IMemoryAccess rom, out int address) Parameters rom IMemoryAccess Memory accessor address int Offset to apply checksum to Returns ReadOnlySpan<byte> Checksum bytes"
  },
  "api/RetroEditor.Plugins.ITile.html": {
    "href": "api/RetroEditor.Plugins.ITile.html",
    "title": "Interface ITile | RetroEditor",
    "keywords": "Interface ITile Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a tile - used by the TileMapWidget class public interface ITile Properties Height Height of the tile in pixels uint Height { get; } Property Value uint Name Name of the tile - displayed in the tile palette string Name { get; } Property Value string Width Width of the tile in pixels uint Width { get; } Property Value uint Methods GetImageData() Get the image data for the tile Pixel[] GetImageData() Returns Pixel[] Flat array of Pixel values representing the image"
  },
  "api/RetroEditor.Plugins.ITileMap.html": {
    "href": "api/RetroEditor.Plugins.ITileMap.html",
    "title": "Interface ITileMap | RetroEditor",
    "keywords": "Interface ITileMap Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a tile map - used by the TileMapWidget class public interface ITileMap Properties Height Height in pixels of the map uint Height { get; } Property Value uint NumLayers Number of layers in the map uint NumLayers { get; } Property Value uint ScaleX X Scale of the tiles float ScaleX { get; } Property Value float ScaleY Y Scale of the tiles float ScaleY { get; } Property Value float Width Width in pixels of the map uint Width { get; } Property Value uint Methods FetchLayer(uint) Get the layer data for the specified layer ILayer FetchLayer(uint layer) Parameters layer uint layer to get tiles for Returns ILayer Array of tiles FetchPalette(uint) Fetch tile palette for the map TilePaletteStore FetchPalette(uint layer) Parameters layer uint layer to get tiles for Returns TilePaletteStore Tile palette storage"
  },
  "api/RetroEditor.Plugins.ITilePalette.html": {
    "href": "api/RetroEditor.Plugins.ITilePalette.html",
    "title": "Interface ITilePalette | RetroEditor",
    "keywords": "Interface ITilePalette Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a tile map palette - used by the TileMapWidget class public interface ITilePalette Properties MaxTiles Maximum number of tiles that can be selected from uint MaxTiles { get; } Property Value uint ScaleX X Scale of the tiles float ScaleX { get; } Property Value float ScaleY Y Scale of the tiles float ScaleY { get; } Property Value float SelectedTile Current chosen palette index int SelectedTile { get; set; } Property Value int TilesPerRow Number of tiles per row in the palette uint TilesPerRow { get; } Property Value uint Methods FetchTiles() Get the tile palette ReadOnlySpan<ITile> FetchTiles() Returns ReadOnlySpan<ITile> Array of tiles Update(float) Can be used to refresh the tile map graphics void Update(float seconds) Parameters seconds float seconds since editor started"
  },
  "api/RetroEditor.Plugins.IUserWindow.html": {
    "href": "api/RetroEditor.Plugins.IUserWindow.html",
    "title": "Interface IUserWindow | RetroEditor",
    "keywords": "Interface IUserWindow Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a window that can be opened by the user. public interface IUserWindow Properties UpdateInterval Update interval for the window in seconds. float UpdateInterval { get; } Property Value float Methods ConfigureWidgets(IMemoryAccess, IWidget, IPlayerControls) Called when the window is opened, to allow the window to define its widgets void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) Parameters rom IMemoryAccess memory interface widget IWidget widget interface playerControls IPlayerControls player controls inteface OnClose() Called when the window is closed, to allow the window to clean up any resources void OnClose()"
  },
  "api/RetroEditor.Plugins.IWidget.html": {
    "href": "api/RetroEditor.Plugins.IWidget.html",
    "title": "Interface IWidget | RetroEditor",
    "keywords": "Interface IWidget Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for creating widgets public interface IWidget Methods AddBitmapWidget(IBitmapImage) Adds a bitmap image editor to the window IWidgetItem AddBitmapWidget(IBitmapImage image) Parameters image IBitmapImage Object implmenting the IBitmapImage interface Returns IWidgetItem Widget AddCheckbox(string, bool, ChangedEventHandler) Add a checkbox to the window IWidgetCheckable AddCheckbox(string label, bool initialValue, ChangedEventHandler changed) Parameters label string Label of the checkbox initialValue bool Initial value of the checkbox changed ChangedEventHandler Delegate called when the value is changed Returns IWidgetCheckable Widget AddImageView(IImage) Adds an image view to the window IWidgetItem AddImageView(IImage image) Parameters image IImage Object implementing the IImage interface Returns IWidgetItem Widget AddLabel(string) Add a label to the window IWidgetLabel AddLabel(string label) Parameters label string Label text Returns IWidgetLabel Widget AddPaletteWidget(IBitmapPalette) Adds a palette widget to the window IWidgetItem AddPaletteWidget(IBitmapPalette palette) Parameters palette IBitmapPalette Object implementing the IBitmapPalette interface Returns IWidgetItem Widget AddSeperator() Add a seperator bar to the window IWidgetItem AddSeperator() Returns IWidgetItem Widget AddSlider(string, int, int, int, ChangedEventHandler) Add a slider to the window IWidgetRanged AddSlider(string label, int initialValue, int min, int max, ChangedEventHandler changed) Parameters label string Lavel of the slider initialValue int Initial value of the slider min int Minimum value of the slider max int Maximum value of the slider changed ChangedEventHandler Delegate called when the value is changed Returns IWidgetRanged Widget AddTileMapWidget(ITileMap) Adds a tile map editor to the window IWidgetItem AddTileMapWidget(ITileMap tileMap) Parameters tileMap ITileMap Object implementing the ITileMap interface Returns IWidgetItem Widget AddTilePaletteWidget(TilePaletteStore) Adds a tile palette editor to the window IWidgetItem AddTilePaletteWidget(TilePaletteStore tilePalette) Parameters tilePalette TilePaletteStore TilePaletteStore object initialized with an ITilePalette object Returns IWidgetItem Widget SameLine() Causes the next widget to be placed on the same line as the previous widget IWidgetItem SameLine() Returns IWidgetItem Widget"
  },
  "api/RetroEditor.Plugins.IWidgetCheckable.html": {
    "href": "api/RetroEditor.Plugins.IWidgetCheckable.html",
    "title": "Interface IWidgetCheckable | RetroEditor",
    "keywords": "Interface IWidgetCheckable Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget that can be checked or unchecked public interface IWidgetCheckable : IWidgetHandleable, IWidgetEnableable, IWidgetItem Inherited Members IWidgetHandleable.Handler IWidgetEnableable.Enabled Properties Checked Is the widget checked bool Checked { get; set; } Property Value bool"
  },
  "api/RetroEditor.Plugins.IWidgetEnableable.html": {
    "href": "api/RetroEditor.Plugins.IWidgetEnableable.html",
    "title": "Interface IWidgetEnableable | RetroEditor",
    "keywords": "Interface IWidgetEnableable Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget that can be enabled or disabled public interface IWidgetEnableable : IWidgetItem Properties Enabled Is the widget enabled bool Enabled { get; set; } Property Value bool"
  },
  "api/RetroEditor.Plugins.IWidgetHandleable.html": {
    "href": "api/RetroEditor.Plugins.IWidgetHandleable.html",
    "title": "Interface IWidgetHandleable | RetroEditor",
    "keywords": "Interface IWidgetHandleable Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget that can notify of a value change public interface IWidgetHandleable : IWidgetEnableable, IWidgetItem Inherited Members IWidgetEnableable.Enabled Properties Handler Handler for the changed event ChangedEventHandler? Handler { get; set; } Property Value ChangedEventHandler"
  },
  "api/RetroEditor.Plugins.IWidgetItem.html": {
    "href": "api/RetroEditor.Plugins.IWidgetItem.html",
    "title": "Interface IWidgetItem | RetroEditor",
    "keywords": "Interface IWidgetItem Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget item that can be added to a window public interface IWidgetItem"
  },
  "api/RetroEditor.Plugins.IWidgetLabel.html": {
    "href": "api/RetroEditor.Plugins.IWidgetLabel.html",
    "title": "Interface IWidgetLabel | RetroEditor",
    "keywords": "Interface IWidgetLabel Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget that can display a label public interface IWidgetLabel : IWidgetItem Properties Name Name (used to allow changing the label dynamically) string Name { get; set; } Property Value string"
  },
  "api/RetroEditor.Plugins.IWidgetRanged.html": {
    "href": "api/RetroEditor.Plugins.IWidgetRanged.html",
    "title": "Interface IWidgetRanged | RetroEditor",
    "keywords": "Interface IWidgetRanged Namespace RetroEditor.Plugins Assembly RetroEditor.dll Interface for a widget that has a ranged value public interface IWidgetRanged : IWidgetHandleable, IWidgetEnableable, IWidgetItem Inherited Members IWidgetHandleable.Handler IWidgetEnableable.Enabled Properties Value The value of the widget int Value { get; set; } Property Value int"
  },
  "api/RetroEditor.Plugins.LogType.html": {
    "href": "api/RetroEditor.Plugins.LogType.html",
    "title": "Enum LogType | RetroEditor",
    "keywords": "Enum LogType Namespace RetroEditor.Plugins Assembly RetroEditor.dll The type of the Log Message, used to categorize the message. public enum LogType Fields Debug = 0 Debug messages are not shown in release builds, and are used for debugging purposes. Error = 3 Error messages are used to inform the user of something that is important. Info = 1 Info messages are used to inform the user of something, but are not considered important. Warning = 2 Warning messages are used to inform the user of something that might be important."
  },
  "api/RetroEditor.Plugins.MemoryEndian.html": {
    "href": "api/RetroEditor.Plugins.MemoryEndian.html",
    "title": "Enum MemoryEndian | RetroEditor",
    "keywords": "Enum MemoryEndian Namespace RetroEditor.Plugins Assembly RetroEditor.dll Endianess of memory - used to determine how to read/write multi-byte values public enum MemoryEndian Fields Big = 1 Big endian - most significant byte first Little = 0 Little endian - least significant byte first"
  },
  "api/RetroEditor.Plugins.MenuEventHandler.html": {
    "href": "api/RetroEditor.Plugins.MenuEventHandler.html",
    "title": "Delegate MenuEventHandler | RetroEditor",
    "keywords": "Delegate MenuEventHandler Namespace RetroEditor.Plugins Assembly RetroEditor.dll Callback for menu events public delegate void MenuEventHandler(IEditor editorInterface, IMenuItem menu) Parameters editorInterface IEditor editor interface menu IMenuItem menu item that was picked"
  },
  "api/RetroEditor.Plugins.Pixel.html": {
    "href": "api/RetroEditor.Plugins.Pixel.html",
    "title": "Struct Pixel | RetroEditor",
    "keywords": "Struct Pixel Namespace RetroEditor.Plugins Assembly RetroEditor.dll A pixel in an image, 8:8:8:8 RGBA format public struct Pixel Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Pixel() Create a pixel with the default values public Pixel() Pixel(byte, byte, byte, byte) Create a pixel with the specified values public Pixel(byte r, byte g, byte b, byte a = 255) Parameters r byte red value g byte green value b byte blue value a byte alpha value Properties Alpha Alpha value public readonly byte Alpha { get; } Property Value byte Blue Blue value public readonly byte Blue { get; } Property Value byte Green Green value public readonly byte Green { get; } Property Value byte Red Red value public readonly byte Red { get; } Property Value byte"
  },
  "api/RetroEditor.Plugins.ReadKind.html": {
    "href": "api/RetroEditor.Plugins.ReadKind.html",
    "title": "Enum ReadKind | RetroEditor",
    "keywords": "Enum ReadKind Namespace RetroEditor.Plugins Assembly RetroEditor.dll Memory region to read from public enum ReadKind Fields Ram = 0 Read from RAM Rom = 1 Read from ROM"
  },
  "api/RetroEditor.Plugins.WriteKind.html": {
    "href": "api/RetroEditor.Plugins.WriteKind.html",
    "title": "Enum WriteKind | RetroEditor",
    "keywords": "Enum WriteKind Namespace RetroEditor.Plugins Assembly RetroEditor.dll Memory region to write to public enum WriteKind Fields SerialisedRam = 4096 Write to RAM (persists to final modded game - assuming ram area saved to disk) SerialisedRom = 4097 Write to ROM (persists to final modded game - assuming rom area saved to disk) TemporaryRam = 0 Write to RAM (does not persist to final modded game - use for cheats, etc) TemporaryRom = 1 Write to ROM (does not persist to final modded game - use for cheats, etc)"
  },
  "api/RetroEditor.Plugins.ZXSpectrum48ImageHelper.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrum48ImageHelper.html",
    "title": "Class ZXSpectrum48ImageHelper | RetroEditor",
    "keywords": "Class ZXSpectrum48ImageHelper Namespace RetroEditor.Plugins Assembly RetroEditor.dll Helper class for rendering a ZX Spectrum 48K screen, this will probably be abstracted out to a more generic class in the future. public class ZXSpectrum48ImageHelper Inheritance object ZXSpectrum48ImageHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is not stored in specutrm screen order, but is a high res bitmap with low res colour. Constructors ZXSpectrum48ImageHelper(uint, uint) Create a new ZX Spectrum 48K image helper. public ZXSpectrum48ImageHelper(uint widthPixels, uint heightPixels) Parameters widthPixels uint width of image in pixels heightPixels uint height of image in pixels Methods Clear(byte) Clear the image to a specific attribute. public void Clear(byte attribute) Parameters attribute byte attribute byte ConvertXBitmapPosToYAttribute(uint) Helper function to convert from a pixel x position to an attribute x position. public uint ConvertXBitmapPosToYAttribute(uint x) Parameters x uint x position in pixels Returns uint x position in attribute cells ConvertYBitmapPosToYAttribute(uint) Helper function to convert from a pixel y position to an attribute y position. public uint ConvertYBitmapPosToYAttribute(uint y) Parameters y uint y position in pixels Returns uint y position in attribute cells CopyBitmapFrom(ZXSpectrum48ImageHelper) Copy the contents of specified image to this image. At present images should be the same size! public void CopyBitmapFrom(ZXSpectrum48ImageHelper source) Parameters source ZXSpectrum48ImageHelper Source image to copy from Draw8Bits(uint, uint, byte, byte, bool) Draws a set of 8 pixels horizontally to the screen. Bits set will be ink, bits not set will be paper. Attribute will be updated for the 8 pixels drawn. public void Draw8Bits(uint x, uint y, byte bits, byte attribute, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing 8 pixels attribute byte attribute byte flipX bool if true bits are drawn from right to left. Draw8BitsInkOnly(uint, uint, byte, byte, bool) Draws a set of 8 pixels horizontally to the screen ignores paper bits. Updates ink attribute only public void Draw8BitsInkOnly(uint x, uint y, byte bits, byte attribute, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing 8 pixels, only set bits will update the image attribute byte attribute byte (only ink colour used) flipX bool if true bits are drawn from right to left. Draw8BitsNoAttribute(uint, uint, byte, bool) Draws a set of 8 pixels horizontally to the screen. Bits set will be ink, bits not set will be paper. public void Draw8BitsNoAttribute(uint x, uint y, byte bits, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing 8 pixels flipX bool if true bits are drawn from right to left. Draw8BitsNoAttributeInkOnly(uint, uint, byte, bool) Draws a set of 8 pixels horizontally to the screen ignores paper bits. public void Draw8BitsNoAttributeInkOnly(uint x, uint y, byte bits, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing 8 pixels, only set bits will update the image flipX bool if true bits are drawn from right to left. Draw8x8(uint, uint, ReadOnlySpan<byte>, byte) Draw an 8x8 tile to the screen, this will update the attribute map. The tile should be an array of 8 bytes. The first byte represents the first row.. etc. public void Draw8x8(uint x, uint y, ReadOnlySpan<byte> tile, byte attribute) Parameters x uint x position to draw tile in pixels y uint y position to draw tile in pixels tile ReadOnlySpan<byte> array of 8 bytes representing the tile to draw attribute byte attribute byte Draw8x8InkOnly(uint, uint, ReadOnlySpan<byte>, byte) Draw an 8x8 tile to the screen, ignores paper bits. The attribute map will be updated with the ink colour only. public void Draw8x8InkOnly(uint x, uint y, ReadOnlySpan<byte> tile, byte attribute) Parameters x uint x position to draw tile in pixels y uint y position to draw tile in pixels tile ReadOnlySpan<byte> array of 8 bytes representing the tile to draw, only set bits are transferred attribute byte DrawBit(uint, uint, bool, byte) Plot a single pixel onto the screen and update the attribute map. public void DrawBit(uint x, uint y, bool ink, byte attribute) Parameters x uint x position in pixels y uint y position in pixels ink bool If true plots in ink colour, otherwise paper attribute byte DrawBitNoAttribute(uint, uint, bool) Plot a single pixel onto the screen. public void DrawBitNoAttribute(uint x, uint y, bool ink) Parameters x uint x position in pixels y uint y position in pixels ink bool If true plots in ink colour, otherwise paper FlipVertical() Flip the current image vertically in place. Only affects bitmap. public void FlipVertical() GetAttribute(uint, uint) Get the attribute at a specific location. public byte GetAttribute(uint ax, uint ay) Parameters ax uint x position in attribute cells ay uint y position in attribute cells Returns byte attribute byte GetBit(uint, uint) Get the value of a pixel at a specific location. public bool GetBit(uint x, uint y) Parameters x uint x position in pixels y uint y position in pixels Returns bool True if the pixel is ink, false if it is paper Render(float) Render the image to a pixel array. public Pixel[] Render(float seconds) Parameters seconds float Used to handle the flash attribute Returns Pixel[] a Pixel array representing the spectrum image at the time indicated SetAttribute(uint, uint, byte) Set the attribute at a specific location. public void SetAttribute(uint ax, uint ay, byte attribute) Parameters ax uint x position in attribute cells ay uint y position in attribute cells attribute byte attribute byte Xor8Bits(uint, uint, byte, byte, bool) Xor a set of 8 pixels horizontally to the screen. Performs an xor between the screen pixel and the bit in the bits byte. Attribute will be updated for the 8 pixels touched. public void Xor8Bits(uint x, uint y, byte bits, byte attribute, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing a set of 8 pixels attribute byte attribute byte flipX bool if true bits are drawn from right to left. Xor8BitsNoAttribute(uint, uint, byte, bool) Xor a set of 8 pixels horizontally to the screen. Performs an xor between the screen pixel and the bit in the bits byte. public void Xor8BitsNoAttribute(uint x, uint y, byte bits, bool flipX) Parameters x uint x position in pixels y uint y position in pixels bits byte byte representing a set of 8 pixels flipX bool if true bits are drawn from right to left."
  },
  "api/RetroEditor.Plugins.ZXSpectrumTape.DataBlock.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrumTape.DataBlock.html",
    "title": "Struct DataBlock | RetroEditor",
    "keywords": "Struct DataBlock Namespace RetroEditor.Plugins.ZXSpectrumTape Assembly RetroEditor.dll Data Block for a ZX Spectrum Tape, generally follows a header block. public ref struct DataBlock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors DataBlock(ReadOnlySpan<byte>) Create a new Data Block from a byte array public DataBlock(ReadOnlySpan<byte> bytes) Parameters bytes ReadOnlySpan<byte> Contents of the data block, only the data block, headers are applied internally Properties Data Returns a ReadOnlySpan of the data in the block public ReadOnlySpan<byte> Data { get; } Property Value ReadOnlySpan<byte> Methods ToString() Fetches a textual representation of the data block public override string ToString() Returns string string representing the contents of the data block"
  },
  "api/RetroEditor.Plugins.ZXSpectrumTape.HeaderBlock.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrumTape.HeaderBlock.html",
    "title": "Struct HeaderBlock | RetroEditor",
    "keywords": "Struct HeaderBlock Namespace RetroEditor.Plugins.ZXSpectrumTape Assembly RetroEditor.dll Header Block for a ZX Spectrum Tape public struct HeaderBlock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors HeaderBlock(HeaderKind, string, ushort, ushort, ushort) Create a new Header Block public HeaderBlock(HeaderKind inType, string inTitle, ushort inDataLength, ushort inParam1, ushort inParam2) Parameters inType HeaderKind Header block type inTitle string Name of block, limited to 10 characters, will be padded if less inDataLength ushort Length of data block that follows inParam1 ushort If Header is Program - AutoStart Line Number, If Header is Code - StartAddress inParam2 ushort If Header is Program - Variable Area Address Offset, If Header is Code - (ignored) Properties Kind The kind of header of this header block public HeaderKind Kind { get; } Property Value HeaderKind Title The title of this header block public string Title { get; } Property Value string Methods ToString() Fetches a textual representation of the header block public override string ToString() Returns string string representing the contents of the header block"
  },
  "api/RetroEditor.Plugins.ZXSpectrumTape.HeaderKind.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrumTape.HeaderKind.html",
    "title": "Enum HeaderKind | RetroEditor",
    "keywords": "Enum HeaderKind Namespace RetroEditor.Plugins.ZXSpectrumTape Assembly RetroEditor.dll The kind of header block to create. Maps to the ZX Spectrum Rom Tape Header types. public enum HeaderKind Fields CharacterArray = 2 ZX Spectrum Character Array Header Code = 3 ZX Spectrum Machine Code Header NumberArray = 1 ZX Spectrum Number Array Header Program = 0 ZX Spectrum Basic Program Header"
  },
  "api/RetroEditor.Plugins.ZXSpectrumTape.Tape.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrumTape.Tape.html",
    "title": "Class Tape | RetroEditor",
    "keywords": "Class Tape Namespace RetroEditor.Plugins.ZXSpectrumTape Assembly RetroEditor.dll Represents a ZX Spectrum Tape image public class Tape : ISave Inheritance object Tape Implements ISave Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Tape() Create a new Tape object public Tape() Methods AddBlock(DataBlock) Add a data block to the tape public void AddBlock(DataBlock data) Parameters data DataBlock DataBlock object to add AddHeader(HeaderBlock) Add a header block to the tape public void AddHeader(HeaderBlock header) Parameters header HeaderBlock HeaderBlock object to add BasicPrograms() Allows iteration of all basic programs on the tape, returning the HeaderBlock and the contents of the data block public IEnumerable<(HeaderBlock header, byte[] data)> BasicPrograms() Returns IEnumerable<(HeaderBlock header, byte[] data)> A Tuple containing the HeaderBlock and the contents of the data block for each basic program Load(string) Create a new Tape object from a file public void Load(string filename) Parameters filename string Path to a .Tap format tape image RegularCodeFiles() Allows iteration of all machine code files on the tape, returning the HeaderBlock and the contents of the data block public IEnumerable<(HeaderBlock header, byte[] data)> RegularCodeFiles() Returns IEnumerable<(HeaderBlock header, byte[] data)> A Tuple containing the HeaderBlock and the contents of the data block for each machine code block in the image Save(string) Write the current tape object to a file (.Tap format image) public void Save(string path) Parameters path string Path to save tape image to Exceptions Exception Throws an exception if the tape is empty ToString() Fetches a textual representation of the tape public override string ToString() Returns string A string representing the tape object"
  },
  "api/RetroEditor.Plugins.ZXSpectrumTape.html": {
    "href": "api/RetroEditor.Plugins.ZXSpectrumTape.html",
    "title": "Namespace RetroEditor.Plugins.ZXSpectrumTape | RetroEditor",
    "keywords": "Namespace RetroEditor.Plugins.ZXSpectrumTape Classes Tape Represents a ZX Spectrum Tape image Structs DataBlock Data Block for a ZX Spectrum Tape, generally follows a header block. HeaderBlock Header Block for a ZX Spectrum Tape Enums HeaderKind The kind of header block to create. Maps to the ZX Spectrum Rom Tape Header types."
  },
  "api/RetroEditor.Plugins.html": {
    "href": "api/RetroEditor.Plugins.html",
    "title": "Namespace RetroEditor.Plugins | RetroEditor",
    "keywords": "Namespace RetroEditor.Plugins Classes ZXSpectrum48ImageHelper Helper class for rendering a ZX Spectrum 48K screen, this will probably be abstracted out to a more generic class in the future. Structs Pixel A pixel in an image, 8:8:8:8 RGBA format Interfaces IBitmapImage Interface for a bitmap image - used with the BitmapWidget class IBitmapPalette Interface for a palette - used with the PaletteWidget class IEditor Editor interface - used to interact with the editor IImage Interface for an image - used by the ImageView class ILayer Interface for a layer in a tile map IMemoryAccess Interface for accessing memory IMenu Interface for creating menus IMenuItem Represents a menu item IMenuProvider Interface for providing menus Allows a plugin to provide a set of menus to the editor IPlayerControls Interface for libretro emulator player IPlayerWindowExtension Interface to allow a plugin to add widgets to the player window. IRetroPlugin The primary interface to implement when developing a new plugin ISave Interface for saving data, intended to be used to generate the final modded game At present only implemented by ZXSpectrumTape ISystemPlugin Defines a system plugin (e.g. Megadrive, NES, etc) ITile Interface for a tile - used by the TileMapWidget class ITileMap Interface for a tile map - used by the TileMapWidget class ITilePalette Interface for a tile map palette - used by the TileMapWidget class IUserWindow Interface for a window that can be opened by the user. IWidget Interface for creating widgets IWidgetCheckable Interface for a widget that can be checked or unchecked IWidgetEnableable Interface for a widget that can be enabled or disabled IWidgetHandleable Interface for a widget that can notify of a value change IWidgetItem Interface for a widget item that can be added to a window IWidgetLabel Interface for a widget that can display a label IWidgetRanged Interface for a widget that has a ranged value Enums LogType The type of the Log Message, used to categorize the message. MemoryEndian Endianess of memory - used to determine how to read/write multi-byte values ReadKind Memory region to read from WriteKind Memory region to write to Delegates ChangedEventHandler Delegate for a changed event. Would be called if a value changes in a widget that supports it MenuEventHandler Callback for menu events"
  },
  "docs/developer-guide.html": {
    "href": "docs/developer-guide.html",
    "title": "Developer Guide | RetroEditor",
    "keywords": "Developer Guide under construction The API Documentation has some information. Creating a plugin from scratch (WIP) Overview For this tutorial, we will take Manic Miner For Gameboy Colour and attempt to make an editor plugin for the rom. This is a homebrew title, and at the time of writing, is on a platform that the editor does not yet have a system plugin or a game plugin for. Initial Setup / Pre-requisites First of all, since we are going to be doing some reverse engineering, we will need to enable developer mode. If the editor has not been run before, start it, and then close it again. This will save a default settings.json, which we can the edit. Open the settings.json and locate the line : \"DeveloperMode\": false and replace the false with true, which will enable some extra menu options. For reverse engineering we will use the builtin libretro_Mame debugger, alongside Ghidra for static analysis and recording discoveries, so please make sure to install it. The editor will also have created a folder named Temp, libretro_Mame requires gbc_boot.1 and gbc_boot.2 which should both be placed into Temp/mame/roms/gbcolor/ folder. I won't link to them here, but they should be easy enough to find online. Download the Manic Miner rom and place it into a folder named gbcolor (its location doesn't matter, but the folder name is very important). Creating a new System (Gameboy Colour) At present, the editor does not allow hot reloading of systems, so make sure the editor is closed before we begin. Open the Plugins/Plugins.csproj in your C# Editor of choice, I used Visual Studio Code for this tutorial. Create a new file inside Source/RomPlugins named GameBoyColour.cs. Copy and paste the following code block into the file : using RetroEditor.Plugins; class GameBoyColour : ISystemPlugin { // Name used to identify the system by plugins public static string Name => \"GameBoyColour\"; // libretro plugin name responsible for running gameboy colour roms public string LibRetroPluginName => \"gambatte_libretro\"; // Memory endian of the system public MemoryEndian Endian => MemoryEndian.Little; // This is a rom based system, so requires reload when changing //things public bool RequiresReload => true; } This should be simple enough to understand and at this point, we can save and run the editor. You should now see a GameBoyColour option under the Developer->Plugin Player-> menu, clicking it and then selecting the unzipped Manic Miner rom should cause a player window to open with the rom running inside it. If not check the logs for compilation errors or other libretro errors. Starting to make our plugin Before we even need to think about reverse engineering, we can start to knock up our initial plugin. The interface we need to implement is IRetroPlugin. Before we do this though, we should calculate the checksum of the rom image (this is done, so we the editor can identify which plugin handles which rom). If you have access to md5sum then you can simply use it to calculate the checksum of the unzipped Manic Miner rom. In case you don't, I have done this for you, and it is b13061a4a1a84ef2edb4c9d47f794093. So we can now implement the minimum interface we need to have the plugin startup when you create a project using the above game. So if you haven't done so, close the editor and switch back to your development IDE. Create a new folder in Source/GamePlugins/ called ManicMinerGBC. Then create a new file inside that new folder called ManicMinerGBC.cs and paste the below code into it : using System.IO; using System.Linq; using System.Security.Cryptography; using RetroEditor.Plugins; class ManicMinerGBC : IRetroPlugin { // This is the name of the plugin that will be displayed in the UI public static string Name => \"Manic Miner GameBoy Colour\"; // This is the name of the system (that we created above) used to load this game public string RomPluginName => \"GameBoyColour\"; // Cartridge based games don't typically require an auto-loader (unlike disc/tape based games) public bool RequiresAutoLoad => false; // We can stub this function, it's not required for this plugin public bool AutoLoadCondition(IMemoryAccess romAccess) { return false; } // This function is used to determine if the plugin can handle the given file // So we check if the MD5 hash matches the one for Manic Miner (b13061a4a1a84ef2edb4c9d47f794093) public bool CanHandle(string path) { var manicMinerMD5 = new byte[] { 0xb1, 0x30, 0x61, 0xa4, 0xa1, 0xa8, 0x4e, 0xf2, 0xed, 0xb4, 0xc9, 0xd4, 0x7f, 0x79, 0x40, 0x93 }; if (!File.Exists(path)) { return false; } var md5 = MD5.Create().ComputeHash(File.ReadAllBytes(path)); if (manicMinerMD5.SequenceEqual(md5)) { return true; } return false; } // We dont yet support exporting saves for Manic Miner GBC, so just throw public ISave Export(IMemoryAccess romAcess) { throw new System.NotImplementedException(\"Manic Miner GBC does not support exporting saves, yet\"); } // We can leave this empty for now public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { } } At this point, we can restart the editor, and File->Create New Project selecting the manic miner rom. The Plugin should automatically be selected in the combo box above, and you can click Create Project. You will now see a player window with the game starting up. In addition, the Window menu will now have an item for our newly created project, but the only items available are Open Player and Reload Plugin. At this point we are in a position where we should be able to iterate on the plugin, without needing to restart the Editor. Ghidra Setup Ghidra is a great tool for doing reverse engineering to figure out data formats etc, there is a plugin (GhidraBoy) available for Ghidra 11 so grab both. Unzip Ghidra (but not the GhidraBoy extension), and then launch Ghidra (This is not a Ghidra tutorial, but I will try to cover aspects as needed). Once open, File->Install Extension , click the + add locate the ghidraboy zip. After installation, restart Ghidra. Create a new project, and then press I to import, selecting the manicminer image. GhidraBoy should configure everything correctly, so click OK, and OK once again on the summary dialog. Now double click on the imported file, clicking YES to the Analyze? dialog and then click Analyze. This will attempt to automatically disassemble the rom, giving us an initial starting point. Initial Goal Our initial goal is to try to skip any logos, intros, start menus, so that our player is on the first level when ever we open the plugin. This will give us a good basis for exploring patching, and also lead into figuring out where the level data is stored. Open the retro editor if it isn't already. And open Developer->LibMame Debugger->Launch selecting the manic miner rom, if it fails, its probably because you haven't put the required gb roms in the right place. Note when the libMame debugger is launched, the execution starts paused. You should open the Developer->LibMame Debugger->Cpu State, Disassembly, Memory and Console views as we will need them going forward. So at this point, we should have Ghidra and the Retro Editor open, with Manic Miner paused in the debugger. What we are now going to do, is to try to figure out how to skip the initial screen presented before the menu. Since we don't know anything about this rom, we use a combination of static (Ghidra) and dynamic (The debugger windows in Retro Editor) in order to figure out what we need. You probably will want to make notes too, but for this tutorial I will mostly guiding you explicitly (again, this isn't a Ghidra or reverse engineering tutorial per se). Another handy resource would be documentation about the Game Boy system itself, the Pan Docs will suffice for this. Ghidra should have opened with the entry() function at address 0x100 within view, if not, you can jump to the entry() via the Symbol Tree window, expand Functions and entry should be at the top. If you are observant you will notice that the debugger (Retro Editor) seems to be showing us stopped at address 0x0000. This is becaause the debugger stops at the first executable point, which in the case of the GameBoy happens to be inside the bios. We don't care about the bios, so using the console add a breakpoint at address 100 (bp 100) and then resume execution (go) until we stop at the same address. bp 100 go The bios should flash up the colour Gameboy logo and then the debugger should stop at the entry function we could see in Ghidra. I usually begin by stepping forward (F7 when the disassembly view is focused), and when i reach a CALL instruction, I step over it (F8). If the debugger pauses, then i continue, if the game (or intros or main menu) starts running. Then I reset and start again, but step into the call this time. This attempts to discover if the games intro/start menu are seperated from the level logic (e.g. handled in a custom function). In the case of Manic Miner, we get lucky. From the entry point, we meet a bunch of CALL instructions, but the one located at 0x01D7 does not return. So we start again, this time we step (F7) into the call at 0x01D7, and then continue forward, this time when reach 0x2981 and step over (F8), the intro runs, and then the main menu is shown, but when we press start, we find ourselves back in the debugger. So, if we were to knock out the call at 0x2981 then in theory in our plugin, the game will start on the first level straight away. Load your saved Manic Miner project into the editor. Now in your editor modify : public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { } to make it look like this : public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { // Patch out the main menu/intro () romAccess.WriteBytes(WriteKind.TemporaryRom, 0x2981, new byte[] { 0x00, 0x00, 0x00 }); } save the file, then go back to the editor and select Window-><project_name>->Reload Plugin. Now the player window should re-open and gameplay should start at level 1 without showing the intro/menu. Adding a level select cheat As great as starting at level 1 is, when editing it is helpful if the editor can skip to the level that is being worked on. In order to do this, we need to figure out where in the code the levels are setup, fortunately this will also help us figure out where the level data is for an editor later. According to the Pan Docs Memory Map video RAM can be directly accessed via 0x8000 to 0x9FFF, there is also DMA, but for this particular game, we don't need to worry about that. Now the GameBoy Colour splits it video memory into Tile Data (0x8000-0x97FF) and Tile Maps (0x9800-0x9FFF). In order to figure out where the game data is stored, we could try staring at the Ghidra Code, or maybe looking at the raw rom data, but a smarter solution would be to allow the debugger to find it for us. The libretro_MAME debugger, allows us to stop execution when memory addresses are accessed. Since we know that the tile maps are written to address 0x9800-0x9FFF, we should be able to use this knowledge to isolate the location of the levels. To begin, lets reset the rom we are debugging, and setup an initial watchpoint (a breakpoint that stops on memory access) on the first tile address 0x9800 (length 1), setting it to stop on write (w). In the debugger console execute the following : softreset wpset 9800,1,w Now from the disassembly view, press F5 to resume. The debugger will stop on the first write to the tilemap memory, there will be a number of these, firstly by the bios, then by initialisation in the rom, then by the main menu, and finally by the level setup. Keep resuming, until the main menu is reached, at the main menu press M on the MAME RETRO player window (to start the game). The next time the debugger stops, in theory it is setting up the level. If you wish to see what the tilemap looks like, you can use the memory view and select CGB PPU/:ppu/0/m_vram in the source view and 1800 in the expression. Since we have stopped at the first tile being written, address 1800 will contain a 02 in this case. If we resume, then we can see the whole tilemap in the memory view, if you do this, just repeat the steps from softreset (but don't set another watchpoint) in order to continue with the tutorial below. Assuming you did resume, lets try to see if the tilemap matches the level we are looking at in the player. The Tilemap is 32 bytes wide, each byte representing a tile number to use for that 8x8 block of the image. So we can see 1800 holds a 02, and on the screen the top left tile is a brick pattern. We then see a number of 00's, which seem to represent blank space, then an 08 which seems to be a key, and then a blank followed by a 06 a stalagtite like formation. This all seems to line up with the screen, feel free to try lining up the other items, then softreset etc, and resume the tutorial below. Ok, at this point, we have stopped just after writing the first tile. We can see in the disassembly view that the next instruction is at 716C, and the previous instruction ld (de),a must have written the memory. In the CPU State view, register A contains 02 and registers D&E contain the values 98&00 respectively. Interestingly, looking up, we can see that a ld a,$02 was used to place the value 02 into A, which is odd (if the rom data was just copied to the screen, this wouldn't be the pattern). This means we cannot directly see where the rom data is being read, fortunately, all is not lost. Another handy trick we can use, is to generate a trace of the execution of the processor and record the values in the registers all to a file. We are looking for a pattern or sequence of memory accessing, that would betray the rom location of the tile data. Lets trace writes to the tilemap for the first line, in order to do that, we need to add another watchpoint to stop at the 32nd write, I clear the old watchpoint here, just to avoid stopping again before we hit the added watchpoint, the reason for the second stop, is the CGB has an alternate bank of memory at the same location, which holds the attribute info for a tile (palette colours etc) : wpclear wpset 9820,1,w Now setup the trace, to log to a file named tilemap.txt : trace tilemap.txt,,,{tracelog \"A=%02X BC=%02X%02X DE=%02X%02X HL=%02X%02X \",a,b,c,d,e,h,l} The above command will pair up the BC,DE,HL registers (because we are looking for an address, and on the GameBoy register pairs are used for that kind of access). Press F5, and once the debugger stops again, enter the below to stop the trace : trace off Now, lets open the file we just created in a text editor (you can use notepad if you don't have a favourite), the file should be in the root directory of the Editor application. Search for the address we saw writing to memory 716B, there will only be two (this is because there are only 2 bricks drawn between the first and 32nd - one at the end of the first line, and the other other at the start of the second). If you look up from one of these you should be able to find a jp (hl) at 70F2. This implies there is some sort of jump table going on when drawing out the screen. If we search for 70F2 you will discover there are 32 of these. Which lines up with drawing 1 tile to each location between 9801 and 9820 inclusive. So now we need to look at how the hl value is derived, since presumably hl controls what is drawn for each tile in the screen. Looking up a little from 70F2, there is a ld hl,$7DF3 at 70E9, so lets look at the code between these two locations : ld hl,$7DF3 ; address of 2 byte wide table.. (jump table) add hl,de ; de must contain the offset into the table ld d,h ; save the calculated jump table address to de ld e,l ld a,(hl+) ; put the value of the entry in the jump table into hl ld h,(hl) ld l,a jp (hl) ; jump to the location in hl Address 7DF3 contains a table of addresses, we can use Ghidra to examine this table, and the code reachable from this table. There is however a snag, the gameboy memory is banked, addresses from 4000 to 7FFF are banked rom, meaning the 16k of memory in that area can be pointed to any of the 256k of rom data in the cartridge (in the case of manicminer). There is a special hardware register inside a chip (memory controller) inside the cartridge that controls which 16k section of the cartridge is visible to the cpu in addresses 4000 to 7FFF. We need to know which 16k block is visible at the point of this routine, in order to locate the correct place in Ghidra. You can use the memory view and change the source to Game Boy MBC1 Cartridge/:cartslot:rom_mbc1/0/m_bank_sel_rom in order to figure out which bank is active, the first four hexdigits are for the addresses 0000 to 3FFF, the second four are what we are interested in, these are used for the switchable bank. You should see the value 0004 here. This means it currently points to the 5th 16k bank (0,1,2,3,4), in Ghidra (thanks to the Gameboy plugin), the banks are already setup, so if you press g (goto address) and choose the entry from the pop up in rom4:7df3, it should take you to the correct address. At present, Ghidra does not know what this data is, so we need to tell it. While the cursor is placed on the rom4:7df3 line (on the ??'s), press p (pointer). This will convert the data into a pointer (which is what our jump table contains), looking at the data, I can see what looks like 9 entries, (the addresses seem to be related), so in addition press [ and enter 9, to create an array of 9 entries. You can press enter on one of the entries to jump to the address, and alt+left cursor to go back to the table. If Ghidra hasn't realised there is supposed to be code at a location, pressing c will get Ghidra to disassemble the code. For now, we don't really need to use Ghidra, we can go back to the text file, and try to figure out where the de value is computed. Looking above the code we examined last time, there is A=00 BC=D812 DE=DA00 HL=0000 708D: ld hl,sp+$44 A=00 BC=D812 DE=DA00 HL=DFE3 708F: ld a,(hl+) A=13 BC=D812 DE=DA00 HL=DFE4 7090: ld b,(hl) A=13 BC=D812 DE=DA00 HL=DFE4 7091: ld c,a A=13 BC=D813 DE=DA00 HL=DFE4 7092: ld a,(bc) A=00 BC=D813 DE=DA00 HL=DFE4 7093: ld c,a A=00 BC=D800 DE=DA00 HL=DFE4 7094: cp e A=00 BC=D800 DE=DA00 HL=DFE4 7095: jp nz,$709B A=00 BC=D800 DE=DA00 HL=DFE4 7098: jp $70C9 A=00 BC=D800 DE=DA00 HL=DFE4 70C9: ld hl,sp+$48 A=00 BC=D800 DE=DA00 HL=DFE7 70CB: ld a,(hl+) A=00 BC=D800 DE=DA00 HL=DFE8 70CC: ld d,(hl) A=00 BC=D800 DE=0000 HL=DFE8 70CD: ld e,a A=00 BC=D800 DE=0000 HL=DFE8 70CE: ld a,($7E26) A=00 BC=D800 DE=0000 HL=DFE8 70D1: ld b,a A=00 BC=0000 DE=0000 HL=DFE8 70D2: ld a,($7E25) A=08 BC=0000 DE=0000 HL=DFE8 70D5: ld c,a A=08 BC=0008 DE=0000 HL=DFE8 70D6: ld a,d A=00 BC=0008 DE=0000 HL=DFE8 70D7: add a,$80 A=80 BC=0008 DE=0000 HL=DFE8 70D9: ld l,a A=80 BC=0008 DE=0000 HL=DF80 70DA: ld a,b A=00 BC=0008 DE=0000 HL=DF80 70DB: add a,$80 A=80 BC=0008 DE=0000 HL=DF80 70DD: cp l A=80 BC=0008 DE=0000 HL=DF80 70DE: jr nz,$70E2 A=80 BC=0008 DE=0000 HL=DF80 70E0: ld a,c A=08 BC=0008 DE=0000 HL=DF80 70E1: cp e A=08 BC=0008 DE=0000 HL=DF80 70E2: jp c,$722B A=08 BC=0008 DE=0000 HL=DF80 70E5: sla e A=08 BC=0008 DE=0000 HL=DF80 70E7: rl d This is a big block, however if we compare this block (specifically the register values, with a few other times in the file e.g. search for 708D) : the top 6 lines seem to show BC= moving past consecutive address for example here are 2 sets (side by side) : A=00 BC=D812 DE=DA00 HL=0000 708D: ld hl,sp+$44 A=00 BC=D812 DE=DA00 HL=0000 708D: ld hl,sp+$44 A=00 BC=D812 DE=DA00 HL=DFE3 708F: ld a,(hl+) A=00 BC=D812 DE=DA00 HL=DFE3 708F: ld a,(hl+) A=1B BC=D812 DE=DA00 HL=DFE4 7090: ld b,(hl) A=1C BC=D812 DE=DA00 HL=DFE4 7090: ld b,(hl) A=1B BC=D812 DE=DA00 HL=DFE4 7091: ld c,a A=1C BC=D812 DE=DA00 HL=DFE4 7091: ld c,a A=1B BC=D81B DE=DA00 HL=DFE4 7092: ld a,(bc) A=1C BC=D81C DE=DA00 HL=DFE4 7092: ld a,(bc) A=00 BC=D81B DE=DA00 HL=DFE4 7093: ld c,a A=00 BC=D81C DE=DA00 HL=DFE4 7093: ld c,a Looking at the bottom line here, A=00 BC=D81B && A=00 BC=D81C I'm reasonably confident that A is the tile number and BC is the address it is fetched from. D81B is according to Pan Docs Memory Map, within the work ram (the bank switchable 4k block), this unfortunately means that some other code is responsible for getting the data to that address from the cartridge. Before we try to locate that, lets make sure the memory around D81B looks like our tilemap. Set the memory view source to Sharp LR35902 ':mainpu' program space memory and the address to D81B. This certainly looks like it could be the tilemap (the tile numbers are different, but the layout seems possible), if you can't see it, try changing the address to D812 and you should see a 16 which would seem to be the wall tile this time. We can use the same tactic we used to find the writes to video ram, to find the code that is performing the copy : softreset wpclear wpset D812,1,w Set the game running, resume past the first several times the debugger stops (memory being used for bios then clearing) until you get to the main menu. Once you start the game (m), a breakpoint should fire and we will now be in the code responsible for putting the tilemap into ram. This code, looks like a standard copy loop : 2D0B ld a,(bc) ; get byte from source pointer (BC) 2D0C ld (hl+),a ; save byte into dest pointer and increment it (HL) 2D0D inc bc ; increment source pointer 2D0E dec de ; decrement count (DE) 2D0F ld a,b 2D10 or e ; or D and E together 2D11 jr nz,$2D0B ; if the combined result is non zero, we need to loop around and copy more Now, if you look at the value of B & C in the CPU State view, you should see 40 & 00 respectively, so this register pair is pointing into the cartridge, again into the bankable rom slot. So using the memory view (Note you can open multiple memory views), set source to Game Boy MBC1 Cartridge/:cartslot:rom_mbc1/0/m_bank_sel_rom and taking a look at the second set of four digits, we see 0006. Lets goto that address in Ghidra (g enter 0x4000 and then select rom6), and you should see a familiar string of data - We've found the tilemap for the first level. However, we are not finished here, our task for this part of the tutorial was to figure out how to add a level select widget to our plugin. So far we have located the tilemap (which will be useful in a later section, when we turn to making an editor), but we don't yet know how the levels are chosen between. The first thing to do is to find the code that performed the memory copy, we could use ghidra to find the xref's to the memory copy routine and then examine each one by hand, but I suspect quite a few places perform memory copies. So instead, we return the Editor, where we should still be stopped at the point we copied the first byte. Now we use the history command to list the code addresses that were executed leading up to the breakpoint. Enter the following in the console view : history This will list the last 256 addresses and instructions the cpu on the Game Boy executed, they are listed in oldest to newest order. Reading from the bottom upwards, we can see a 2D23: call $2D09, which will be the parent function calling the copy, so lets look at that code in Ghidra (g enter 0x2D23). This appears to be a wrapper function, if you look at the right hand side (the Decompile window) of Ghidra, it appears to be a function that just directly calls the copy function. So we can ignore this one, go back to the history and find the next oldest call instruction, in this case 17F4: call $2D14. If we look at that function in Ghidra again looking at the Decompile view, this looks more promising : void FUN_178f(byte param_5) { byte bVar1; DAT_c17c = 0x12; DAT_c17d = 0xd8; DAT_c118 = param_5; if (param_5 < 0x10) { FUN_0317(); CopyMemory(CONCAT11(DAT_c17d,DAT_c17c), (uint)(byte)((((((((byte)(param_5 << 2) >> 7) << 1 | (byte)(param_5 << 3) >> 7) << 1 | (byte)(param_5 << 4) >> 7) << 1 | (byte)(param_5 << 5) >> 7) << 1 | (byte)(param_5 << 6) >> 7) << 1 | param_5 & 1) << 2) * 0x100 + 0x4000, 0x400); FUN_034f(); } else { FUN_0317(); bVar1 = param_5 - 0x10; CopyMemory(CONCAT11(DAT_c17d,DAT_c17c), (uint)(byte)((((((((byte)(bVar1 * '\\x04') >> 7) << 1 | (byte)(bVar1 * '\\b') >> 7) << 1 | (byte)(param_5 * '\\x10') >> 7) << 1 | (byte)(param_5 * ' ') >> 7 ) << 1 | (byte)(param_5 * '@') >> 7) << 1 | bVar1 & 1) << 2) * 0x100 + 0x6ddc,0x400); FUN_034f(); } bVar1 = LCDC; LCDC = bVar1 & 0x7f; FUN_0317(); func_0x6f3b(); FUN_034f(); return; } param_5 in the above code seems important, there is a comparison against 0x10 which seems to be used to modify the calculation for the memory copy, perhaps the first 16 levels are stored in a different location to the last few. DAT_c118 seems to have param_5 copied into it, perhaps DAT_c118 is used to store the current level number. In the Decompile view in Ghidra, place the cursor on the DAT_c118 and press enter, which will cause the Listing view to show the location of that variable. It will be ?? because Ghidra is only a static analysis tool, it can't have knowledge of writes to ram. We could look at address C118 in the memory view in the debugger, but for now, lets continue with Ghidra. In the listing view, you should see something like : DAT_c118 XREF[8]: FUN_146f:16d6(R), FUN_178f:179d(W), FUN_186e:187c(W), FUN_1cff:1faa(R), FUN_1cff:2268(R), FUN_1cff:231d(R), FUN_1cff:2323(W), FUN_1cff:2473(R) c118 undefined1 ?? The XREF's show reads and writes to the address, the write at FUN_178f:179d is the one we already saw, that leaves two other writes. We are looking for something that reads and increments the value and puts it back. We can double click on the references to follow them, allowing us to look at the code in place. The write at FUN_186e:187c appears to be a similar (but simpler) version of the first function. However the write at FUN_1cff:2323 shows the following code. 231d fa 18 c1 LD A,(DAT_c118) = ?? 2320 5f LD E,A 2321 1c INC E 2322 7b LD A,E 2323 ea 18 c1 LD (DAT_c118),A = ?? This certainly looks like something incrementing the level counter, this code lives inside a huge function at 1CFF, in order to save time in this tutorial, I can tell you it is the function that handles the gameplay (winning levels, level logic, death etc). Scrolling up a little from our current location you should find a label LAB_22f7, I think this is probably the code responsible for setting up the next level after you complete a level. It turns out that there is code specifically for setting up the first level near the top of this function, but I've spent long enough on getting us to this point, and we haven't actually got to the point of adding some code to our plugin. So taking a small shortcut, lets update the SetupGameTemporaryPatches method and I will explain it below : public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { // Patch out the main menu/intro () romAccess.WriteBytes(WriteKind.TemporaryRom, 0x2981, new byte[] { 0x00, 0x00, 0x00 }); // Try forcing level 4 (4 - 2 == 2nd byte) romAccess.WriteBytes(WriteKind.TemporaryRom, 0x1d7d, new byte[] { 0x3E, 0x02, // LD A, 2 0xEA, 0x18 , 0xC1, // LD (C118), A 0xC3, 0xF7, 0x22 }); // JP 22F7 } This patches the start of the game level code function (1CFF) to store a value into the level counter, and then jump to the code responsible for setting up the next level after completing it. We use 2 even though we want level 4, because the code that sets up a new level (22F7) increments the level variable, we need to subtract 1. In addtion, the level variable is 0 based, ie 00 is level 1, so we need to subtract another 1. Reload the plugin with this code in place, and after a few seconds (at some point we should try and remove this stall), the game should start on Abandoned Uranium Workings. It seems to work (although if all lives are lost, things do go wrong), so lets try adding a control to choose which level is currently running. In order to add a control to the player window (which is built in), we need to implement IPlayerWindowExtension, so add the interface to our plugin : class ManicMinerGBC : IRetroPlugin, IPlayerWindowExtension This extension requires a new method to be implemented : public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls); So lets add the following code (which will add a slider widget to the player screen) into the ManicMinerGBC class : IWidgetRanged levelValue; public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { levelValue = widget.AddSlider(\"Level\", 1, 1, 20, () => playerControls.Reset()); } And reload the plugin. You will need to make the player view a little bigger vertically, in order to see the slider (window sizes are automatically computed, however when adding controls to windows that have existed, they retain their position and size from the previous time). Moving the slider, will reset the game, but it will always be on level 4 (because we haven't yet used the value in the slider), lets fix that : public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { // Patch out the main menu/intro () romAccess.WriteBytes(WriteKind.TemporaryRom, 0x2981, new byte[] { 0x00, 0x00, 0x00 }); // Set level to match slider value romAccess.WriteBytes(WriteKind.TemporaryRom, 0x1d7d, new byte[] { 0x3E, (byte)(levelValue.Value-2), // LD A, (slider value - 2) 0xEA, 0x18 , 0xC1, // LD (C118), A 0xC3, 0xF7, 0x22 }); // JP 22F7 } Now, when you reload the plugin, the slider will change the level as we would expect. Adding a tilemap editor The function at 178F seems to indicate that levels 1-16 are located at address 4000 - 7FFF in rom6, and levels 17-20 are located at address 6DDC - 7DDB in rom7. Each block of level data is 400 (1k) in size. We know the tilemap is at the start of the data block, but not much else. The Game Boy screen is 160x144 pixels, there are 2 tile rows used for the levelname and status row, so that would leave 16 tiles high (144/8 - 2). 16*32 = 512, so the first 512 bytes are the tile map. We still need to figure out where the tile data is, we could use the same technique of putting a watch for a write to memory, this time a write to the tile data area 8000 to 97FF and then try to track it back to where the data is coming from in the rom cartridge. However, manicminer.gbc appears to use the same level data as the original (zx spectrum) game, which means we can use someone elses work to figure out how to build a tilemap editor. Manic Miner Room-Format has a lot of details about the original, I've reproduced a little here in case the website goes down. If we look at the first level (18000 - 183FF in absolute offset from start of rom), it breaks down roughly as follows : Offset In Rom Offset from start of level data Size Meaning 0x18000 0 512 Level Layout 0x18200 512 32 Level name 0x18220 544 72 Block Graphics This should be enough to make a start on our tilemap editor. The first thing we need to do, is add a menu in order to bring up our editing window. For now, lets keep things simple and just work on the first level. We can add a menu by implementing the IMenuProvider, so add the interface to our plugin : class ManicMinerGBC : IRetroPlugin, IPlayerWindowExtension, IMenuProvider We are required to implement : public void ConfigureMenu(IMemoryAccess rom, IMenu menu) This method lets us add custom menus to our plugin, they will appear under Window-> -> and you can create submenus as you see fit. For now, we just need a window in order to experiment. Add the following code : public void ConfigureMenu(IMemoryAccess rom, IMenu menu) { menu.AddItem(\"Edit Level 1\", (editorInterface,menuItem) => { //editorInterface.OpenUserWindow($\"Edit Level 1\", new ManicMinerTileEditor(rom)); }); } If you reload the plugin, you will now see a new menu item, although since we commented out the open window call, it won't do anything just yet. Next up, we need to add a class that implements the IUserWindow interface, this will allow us to comment out the line above. class ManicMinerTileEditor : IUserWindow { public float UpdateInterval => 1 / 30.0f; public ManicMinerTileEditor(IMemoryAccess rom) { // Do nothing for now } public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { // Do nothing for now } public void OnClose() { // Do nothing for now } } Now, if you uncomment the line in ConfigureMenu, and reload the plugin, you can use the menu to open a window, although we haven't yet done anything useful with the window. The window will be tiny, because we haven't given it any widgets, lets deal with that next. At present when reloading a plugin, all windows apart from the player window are closed, at some point I hope to change that, but for now, you will have to re-open the edit level window when you reload the plugin. Since we are trying to make an editor to edit the layout of the room, we will need two widgets, a TilePaletteWidget and a TileMapWidget. The first is used to represent the tiles that can be used, and the second is the layout of the map. Lets begin with the palette, we will need a couple of helper classes adding, lets start with the ManicMinerTile : public class ManicMinerTile : ITile { Pixel[] imageData; string name; public ManicMinerTile(IMemoryAccess rom, uint offset, string name) { this.imageData = Array.Empty<Pixel>(); this.name = name; } public uint Width => 8; public uint Height => 8; public string Name => name; public void Update(Pixel[] imageData) { this.imageData = imageData; } public Pixel[] GetImageData() { return imageData; } } This class will hold our tile representations, it implements the ITile interface. The next class will hold our palette of tiles, implementing the ITilePalette interface. class ManicMinerTilePalette : ITilePalette { public uint MaxTiles => 8; public int SelectedTile { get; set; } public float ScaleX => 2.0f; public float ScaleY => 2.0f; public uint TilesPerRow => 4; public TilePaletteStore tilePaletteStore; ManicMinerTile[] tiles; public ManicMinerTilePalette(IMemoryAccess rom) { tiles = Array.Empty<ManicMinerTile>(); tilePaletteStore = new TilePaletteStore(this); } public void Update(float seconds) { // Do nothing for now } public ReadOnlySpan<ITile> FetchTiles() { return tiles; } } Finally update the ManicMinerTileEditor as follows : class ManicMinerTileEditor : IUserWindow { public float UpdateInterval => 1 / 30.0f; private ManicMinerTilePalette tilePalette; public ManicMinerTileEditor(IMemoryAccess rom) { tilePalette = new ManicMinerTilePalette(rom); } public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { widget.AddLabel(\"Palette\"); widget.AddTilePaletteWidget(tilePalette.tilePaletteStore); } public void OnClose() { // Do nothing for now } } You should be able to reload the plugin at this point, although the only change to the editor window will be the word Palette. However don't fret, we can try and extract the graphics we will need for the palette. According to Block Graphics Section of the Manic Miner Data Format the block graphics are stored in the offsets 544-615, each of which is 9 bytes in size. The first byte is the colour attribute, the next 8 bytes are a bitmap representing the 8x8 tile. We need the tilemap to be in non palettised format in order for the editor to render it. So lets modify the constructor of the tile to perform this conversion : public ManicMinerTile(IMemoryAccess rom, uint offset, string name) { this.imageData = new Pixel[8 * 8]; var tileData = rom.ReadBytes(ReadKind.Rom, offset, 9); this.name = name; // See appendix A in the manicminer format (or a zx spectrum colour attribute document) var attr = tileData[0]; var inkColour = attr & 0x07; // The lower 3 bits are the ink colour (RGB) var paperColour = (attr >> 3) & 0x07; // The next 3 bits are the paper colour (RGB) var bright = (attr & 0x40) != 0 ? 63 : 0; // The 7th bit is the bright flag var inkBright = (inkColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 var paperBright = (paperColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 // combine attributes to form a colour for ink and paper (R = 0 or 192, G = 0 or 192, B = 0 or 192) + bright var ink = new Pixel((byte)((inkColour & 2) * 96 + inkBright), (byte)((inkColour & 4) * 48 + inkBright), (byte)((inkColour & 1) * 192 + inkBright)); var paper = new Pixel((byte)((paperColour & 2) * 96 + paperBright), (byte)((paperColour & 4) * 48 + paperBright), (byte)((paperColour & 1) * 192 + paperBright)); for (int y = 0; y < 8; y++) { var row = tileData[y + 1]; for (int x = 0; x < 8; x++) { var pixel = (row & (1 << (7 - x))) != 0 ? ink : paper; imageData[y * 8 + x] = pixel; } } } Now we can initialise our 8 tiles from the offsets we are given in the Block Graphics Section of the Manic Miner Data Format. So update the constructor of the tile palette as follows : public ManicMinerTilePalette(IMemoryAccess rom) { tiles = new ManicMinerTile[8]; tiles[0] = new ManicMinerTile(rom, 0x4000 * 6 + 544, \"Background\"); tiles[1] = new ManicMinerTile(rom, 0x4000 * 6 + 553, \"Floor\"); tiles[2] = new ManicMinerTile(rom, 0x4000 * 6 + 562, \"Crumbling Floor\"); tiles[3] = new ManicMinerTile(rom, 0x4000 * 6 + 571, \"Wall\"); tiles[4] = new ManicMinerTile(rom, 0x4000 * 6 + 580, \"Conveyor\"); tiles[5] = new ManicMinerTile(rom, 0x4000 * 6 + 589, \"Nasty 1\"); tiles[6] = new ManicMinerTile(rom, 0x4000 * 6 + 598, \"Nasty 2\"); tiles[7] = new ManicMinerTile(rom, 0x4000 * 6 + 607, \"Spare\"); tilePaletteStore = new TilePaletteStore(this); } Now if you reload, your window should have 8 tiles you can select between. In order to be able to make modifications to the level, we will need another widget. The TileMapWidget also needs a few interfaces implementing, first up, we need a layer ILayer. class ManicMinerTileMapLayer : ILayer { public uint Width => 32; public uint Height => 16; uint[] mapData; public ManicMinerTileMapLayer(IMemoryAccess rom, uint offset, ManicMinerTilePalette tilePalette) { mapData = new uint[Width * Height]; } public ReadOnlySpan<uint> GetMapData() { return mapData; } public void SetTile(uint x, uint y, uint tile) { mapData[y * Width + x] = tile; } } The width and height for the layer are expressed in tiles, and we temporarily construct an empty map, which we will populate from the games level data a little later. Next up, we need an implementation of ITileMap this defines the maximum pixel size of the map, along with accessors for the layers and palette in use by the map. class ManicMinerTileMap : ITileMap { public uint Width => 32 * 8; public uint Height => 16 * 8; public uint NumLayers => 1; public float ScaleX => 2.0f; public float ScaleY => 2.0f; private TilePaletteStore _tilePaletteStore; private ManicMinerTileMapLayer _layer; public ManicMinerTileMap(IMemoryAccess rom, uint offset, ManicMinerTilePalette tilePalette) { _tilePaletteStore = tilePalette.tilePaletteStore; _layer = new ManicMinerTileMapLayer(rom, offset, tilePalette); } public ILayer FetchLayer(uint layer) { return _layer; } public TilePaletteStore FetchPalette(uint layer) { return _tilePaletteStore; } } Finally, we update the ManicMinerTileEditor class as follows (adding the tilemap widget) : class ManicMinerTileEditor : IUserWindow { public float UpdateInterval => 1 / 30.0f; private ManicMinerTilePalette tilePalette; private ManicMinerTileMap tileMap; public ManicMinerTileEditor(IMemoryAccess rom) { tilePalette = new ManicMinerTilePalette(rom); tileMap = new ManicMinerTileMap(rom, 0x4000 * 6 + 0, tilePalette); } public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { widget.AddLabel(\"Palette\"); widget.AddTilePaletteWidget(tilePalette.tilePaletteStore); widget.AddLabel(\"TileMap\"); widget.AddTileMapWidget(tileMap); } public void OnClose() { // Do nothing for now } } Note in the above, we are passing the address of the data in the cartridge that contains the data we will need to edit the actual level (4000*6+0), but we are not using it yet. At this point, you can reload the plugin. and now you can paint tiles onto the map, but the map does not contain the data from the game, and we can't affect the game either. Looking at the Manic Miner Screen Layout, it turns out the data is stored in a slighty odd fashion. The 512 (32*16) bytes of the screen layout map 1 to 1 with tiles in our tilemap, however instead of the byte containing a tile number, it contains the attribute used to colour the particular tile. So we need to map tile attributes to our tile indices. First up, adjust the ManicMinerTile class so we can access the attribute for a tile, here is the full code, but essentially I've just added an Attr property to return the attribute value from the first byte in the tiledata : public class ManicMinerTile : ITile { Pixel[] imageData; string name; byte _attr; // Assume offset points to the start of the tile public ManicMinerTile(IMemoryAccess rom, uint offset, string name) { this.imageData = new Pixel[8 * 8]; var tileData = rom.ReadBytes(ReadKind.Rom, offset, 9); this.name = name; // See appendix A in the manicminer format (or a zx spectrum colour attribute document) _attr = tileData[0]; var inkColour = _attr & 0x07; // The lower 3 bits are the ink colour (RGB) var paperColour = (_attr >> 3) & 0x07; // The next 3 bits are the paper colour (RGB) var bright = (_attr & 0x40) != 0 ? 63 : 0; // The 7th bit is the bright flag var inkBright = (inkColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 var paperBright = (paperColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 // combine attributes to form a colour for ink and paper (R = 0 or 192, G = 0 or 192, B = 0 or 192) + bright var ink = new Pixel((byte)((inkColour & 2) * 96 + inkBright), (byte)((inkColour & 4) * 48 + inkBright), (byte)((inkColour & 1) * 192 + inkBright)); var paper = new Pixel((byte)((paperColour & 2) * 96 + paperBright), (byte)((paperColour & 4) * 48 + paperBright), (byte)((paperColour & 1) * 192 + paperBright)); for (int y = 0; y < 8; y++) { var row = tileData[y + 1]; for (int x = 0; x < 8; x++) { var pixel = (row & (1 << (7 - x))) != 0 ? ink : paper; imageData[y * 8 + x] = pixel; } } } public uint Width => 8; public uint Height => 8; public string Name => name; public void Update(Pixel[] imageData) { this.imageData = imageData; } public Pixel[] GetImageData() { return imageData; } public byte Attr => _attr; } Now we can access the attribute value from a tile, we can create a dictionary to map between Add the following to the ManicMinerTilePalette class : Dictionary<byte,uint> attrToIndex; Dictionary<uint,byte> indexToAttr; internal uint AttrToIndex(byte attr) { return attrToIndex[attr]; } internal byte IndexToAttr(uint index) { return indexToAttr[index]; } also modify the constructor to initialise attrToIndex : public ManicMinerTilePalette(IMemoryAccess rom) { tiles = new ManicMinerTile[8]; tiles[0] = new ManicMinerTile(rom, 0x4000 * 6 + 544, \"Background\"); tiles[1] = new ManicMinerTile(rom, 0x4000 * 6 + 553, \"Floor\"); tiles[2] = new ManicMinerTile(rom, 0x4000 * 6 + 562, \"Crumbling Floor\"); tiles[3] = new ManicMinerTile(rom, 0x4000 * 6 + 571, \"Wall\"); tiles[4] = new ManicMinerTile(rom, 0x4000 * 6 + 580, \"Conveyor\"); tiles[5] = new ManicMinerTile(rom, 0x4000 * 6 + 589, \"Nasty 1\"); tiles[6] = new ManicMinerTile(rom, 0x4000 * 6 + 598, \"Nasty 2\"); tiles[7] = new ManicMinerTile(rom, 0x4000 * 6 + 607, \"Spare\"); tilePaletteStore = new TilePaletteStore(this); attrToIndex = new Dictionary<byte, uint>(); indexToAttr = new Dictionary<uint, byte>(); for (int i = 0; i < 8; i++) { attrToIndex[tiles[i].Attr] = (uint)i; indexToAttr[(uint)i] = tiles[i].Attr; } } We now have a way to get from an attribute value to the tile, so we should be able to convert the game representation of the screen data into our tilemap format. To do this, we need to update the ManicMinerTileMapLayer constructor as follows : IMemoryAccess _rom; ManicMinerTilePalette _tilePalette; public ManicMinerTileMapLayer(IMemoryAccess rom, uint offset, ManicMinerTilePalette tilePalette) { _rom = rom; // We record these because they will be useful when we modify the rom _tilePalette = tilePalette; mapData = new uint[Width * Height]; var tileData = rom.ReadBytes(ReadKind.Rom, offset, Width * Height); for (uint y = 0; y < Height; y++) { for (uint x = 0; x < Width; x++) { mapData[y * Width + x] = tilePalette.AttrToIndex(tileData[(int)(y * Width + x)]); } } } Reload the plugin, and you should now see the first level in the tilemap editor. There are some things missing : Enemies Items Exit Before we worry about those things, we should make sure changes are applied back to the game. The easiest way to do this, is to update the SetTile method in ManicMinerTileMapLayer. public void SetTile(uint x, uint y, uint tile) { mapData[y * Width + x] = tile; _rom.WriteBytes(WriteKind.SerialisedRom, 0x4000 * 6 + 0 + y * Width + x, new byte[] { _tilePalette.IndexToAttr(tile) }); } At this point, reload the plugin, and you can modify the level, and if you move the slider on the player window away and back to level 1, your changes should be playable. Adding pickups According to Manic Miner Items each level can have between 0 and 5 items. This means we need to limit the number of times an item can be placed. Items can also overlay ontop of background items (as their positions are stored seperately - although according to the page they should not be placed ontop of other tiles). The graphic for the item is stored at offset 692-699, just the bitmap this time, the colours are stored in the item table. The item table is 5 bytes per item with 5 items per room occupying offsets 629-653, an items 5 bytes break down as : Offset Use 0 Colour attribute of item. Or 0 for not used or 255 to terminate the item list 1 YYYXXXXX where X is the tile column and Y is the tile row (the most significant bit of Y is held in offset 2/3) 2 0101110Y the most significant bit of the tile row (same as offset 3) 3 0110Y000 the most significant bit of the tile row (same as offset 2) 4 11111111 always 255 For simplicity we will extend our current tilemap and palette, adding the items as another tile, and some code to control number of items placed etc. For this, I will just post the full completed code included the changes. using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Security.Cryptography; using RetroEditor.Plugins; class ManicMinerGBC : IRetroPlugin, IPlayerWindowExtension, IMenuProvider { // This is the name of the plugin that will be displayed in the UI public static string Name => \"Manic Miner GameBoy Colour\"; // This is the name of the system (that we created above) used to load this game public string RomPluginName => \"GameBoyColour\"; // Cartridge based games don't typically require an auto-loader (unlike disc/tape based games) public bool RequiresAutoLoad => false; // We can stub this function, it's not required for this plugin public bool AutoLoadCondition(IMemoryAccess romAccess) { return false; } // This function is used to determine if the plugin can handle the given file // So we check if the MD5 hash matches the one for Manic Miner (b13061a4a1a84ef2edb4c9d47f794093) public bool CanHandle(string path) { var manicMinerMD5 = new byte[] { 0xb1, 0x30, 0x61, 0xa4, 0xa1, 0xa8, 0x4e, 0xf2, 0xed, 0xb4, 0xc9, 0xd4, 0x7f, 0x79, 0x40, 0x93 }; if (!File.Exists(path)) { return false; } var md5 = MD5.Create().ComputeHash(File.ReadAllBytes(path)); if (manicMinerMD5.SequenceEqual(md5)) { return true; } return false; } // We dont yet support exporting saves for Manic Miner GBC, so just throw public ISave Export(IMemoryAccess romAcess) { //`File.WriteAllBytes(\"modified.gbc\", romAcess.ReadBytes(ReadKind.Rom, 0, (uint)romAcess.RomSize).ToArray()); throw new System.NotImplementedException(\"Manic Miner GBC does not support exporting saves, yet\"); } public void SetupGameTemporaryPatches(IMemoryAccess romAccess) { // Patch out the main menu/intro () romAccess.WriteBytes(WriteKind.TemporaryRom, 0x2981, new byte[] { 0x00, 0x00, 0x00 }); // Disable bung logo romAccess.WriteBytes(WriteKind.TemporaryRom, 0x296C, new byte[] { 0x00, 0x00, 0x00 }); // Set level to match slider value romAccess.WriteBytes(WriteKind.TemporaryRom, 0x1d7d, new byte[] { 0x3E, (byte)(levelValue.Value-2), // LD A, (slider value - 2) 0xEA, 0x18 , 0xC1, // LD (C118), A 0xC3, 0xF7, 0x22 }); // JP 22F7 } IWidgetRanged levelValue; public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { levelValue = widget.AddSlider(\"Level\", 1, 1, 20, () => playerControls.Reset()); } public void ConfigureMenu(IMemoryAccess rom, IMenu menu) { menu.AddItem(\"Edit Level 1\", (editorInterface,menuItem) => { editorInterface.OpenUserWindow($\"Edit Level 1\", new ManicMinerTileEditor(rom)); }); } } public class ManicMinerTile : ITile { Pixel[] imageData; string name; byte _attr; // Assume offset points to the start of the tile public ManicMinerTile(IMemoryAccess rom, uint offset, string name, bool hasAttributes = true, byte overrideAttr = 0) { this.imageData = new Pixel[8 * 8]; ReadOnlySpan<byte> tileData = hasAttributes ? rom.ReadBytes(ReadKind.Rom, offset, 9) : rom.ReadBytes(ReadKind.Rom, offset, 8); this.name = name; // See appendix A in the manicminer format (or a zx spectrum colour attribute document) SetupAttribute(hasAttributes ? tileData[0] : overrideAttr, out Pixel ink, out Pixel paper); if (hasAttributes) { tileData = tileData[1..]; } for (int y = 0; y < 8; y++) { var row = tileData[y]; for (int x = 0; x < 8; x++) { var pixel = (row & (1 << (7 - x))) != 0 ? ink : paper; imageData[y * 8 + x] = pixel; } } } public void SetupAttribute(byte attr, out Pixel ink, out Pixel paper) { _attr = attr; var inkColour = _attr & 0x07; // The lower 3 bits are the ink colour (RGB) var paperColour = (_attr >> 3) & 0x07; // The next 3 bits are the paper colour (RGB) var bright = (_attr & 0x40) != 0 ? 63 : 0; // The 7th bit is the bright flag var inkBright = (inkColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 var paperBright = (paperColour != 0) ? bright : 0; // bright adds 63 to the colour value if not 0 // combine attributes to form a colour for ink and paper (R = 0 or 192, G = 0 or 192, B = 0 or 192) + bright ink = new Pixel((byte)((inkColour & 2) * 96 + inkBright), (byte)((inkColour & 4) * 48 + inkBright), (byte)((inkColour & 1) * 192 + inkBright)); paper = new Pixel((byte)((paperColour & 2) * 96 + paperBright), (byte)((paperColour & 4) * 48 + paperBright), (byte)((paperColour & 1) * 192 + paperBright)); } public uint Width => 8; public uint Height => 8; public string Name => name; public void Update(Pixel[] imageData) { this.imageData = imageData; } public Pixel[] GetImageData() { return imageData; } public byte Attr => _attr; } class ManicMinerTilePalette : ITilePalette { public uint MaxTiles => 9; public int SelectedTile { get; set; } public float ScaleX => 2.0f; public float ScaleY => 2.0f; public uint TilesPerRow => 4; public TilePaletteStore tilePaletteStore; ManicMinerTile[] tiles; public ManicMinerTilePalette(IMemoryAccess rom) { tiles = new ManicMinerTile[9]; tiles[0] = new ManicMinerTile(rom, 0x4000 * 6 + 544, \"Background\"); tiles[1] = new ManicMinerTile(rom, 0x4000 * 6 + 553, \"Floor\"); tiles[2] = new ManicMinerTile(rom, 0x4000 * 6 + 562, \"Crumbling Floor\"); tiles[3] = new ManicMinerTile(rom, 0x4000 * 6 + 571, \"Wall\"); tiles[4] = new ManicMinerTile(rom, 0x4000 * 6 + 580, \"Conveyor\"); tiles[5] = new ManicMinerTile(rom, 0x4000 * 6 + 589, \"Nasty 1\"); tiles[6] = new ManicMinerTile(rom, 0x4000 * 6 + 598, \"Nasty 2\"); tiles[7] = new ManicMinerTile(rom, 0x4000 * 6 + 607, \"Spare\"); tiles[8] = new ManicMinerTile(rom, 0x4000 * 6 + 692, \"Pickup\", false, 0x07); tilePaletteStore = new TilePaletteStore(this); attrToIndex = new Dictionary<byte, uint>(); indexToAttr = new Dictionary<uint, byte>(); for (int i = 0; i < 8; i++) { attrToIndex[tiles[i].Attr] = (uint)i; indexToAttr[(uint)i] = tiles[i].Attr; } } public void Update(float seconds) { // Do nothing for now } public ReadOnlySpan<ITile> FetchTiles() { return tiles; } Dictionary<byte,uint> attrToIndex; Dictionary<uint,byte> indexToAttr; internal uint AttrToIndex(byte attr) { return attrToIndex[attr]; } internal byte IndexToAttr(uint index) { return indexToAttr[index]; } } class ManicMinerTileMapLayer : ILayer { public uint Width => 32; public uint Height => 16; uint[] mapData; IMemoryAccess _rom; ManicMinerTilePalette _tilePalette; public ManicMinerTileMapLayer(IMemoryAccess rom, uint offset, ManicMinerTilePalette tilePalette) { _rom = rom; // We record these because they will be useful when we modify the rom _tilePalette = tilePalette; mapData = new uint[Width * Height]; var tileData = rom.ReadBytes(ReadKind.Rom, offset, Width * Height); for (uint y = 0; y < Height; y++) { for (uint x = 0; x < Width; x++) { mapData[y * Width + x] = tilePalette.AttrToIndex(tileData[(int)(y * Width + x)]); } } // Add pickup locations _pickupOffset = offset + 629; _pickups = new List<Pickup>(); GetPickups(); foreach (var pickup in _pickups) { mapData[pickup.y * Width + pickup.x] = 8; } } private uint _pickupOffset; private List<Pickup> _pickups; struct Pickup { public byte x; public byte y; public byte attr; } // Convert in memory format to our simple list format public void GetPickups() { _pickups.Clear(); var pickups = _rom.ReadBytes(ReadKind.Rom, _pickupOffset, 5 * 5); for (int i=0;i<5;i++) { if (pickups[i * 5 + 0] == 255) { // no more pickups break; } if (pickups[i * 5 + 0] == 0) { // ignore this pickup continue; } // Get coordinates : var yyyxxxxx = pickups[i * 5 + 1]; var nnnnnnny = pickups[i * 5 + 2]; var x= yyyxxxxx & 0x1f; var y= (yyyxxxxx >> 5) | ((nnnnnnny & 0x1) << 3); _pickups.Add(new Pickup { x = (byte)x, y = (byte)y, attr = pickups[i * 5 + 0] }); } UpdateItemCount(); } // Convert our simple list format to in memory format public void StorePickups() { byte[] pickups = new byte[5 * 5]; int pickupOffset = 0; foreach (var pickup in _pickups) { pickups[pickupOffset++] = pickup.attr; // Attribute pickups[pickupOffset++] = (byte)((pickup.y << 5) | (pickup.x & 0x1f)); // YYYXXXXX var topYBit = (pickup.y >> 3) & 1; pickups[pickupOffset++] = (byte)(topYBit | 0b01011100); // 0101110Y pickups[pickupOffset++] = (byte)((topYBit<<3) | 0b01100000); // 0110Y000 pickups[pickupOffset++] = 255; // Always 255 } if (pickupOffset<5*5) { // Mark end of list pickups[pickupOffset++] = 255; } for (int i=0;i<5;i++) { if (i < _pickups.Count) { var pickup = _pickups[i]; pickups[i * 5 + 0] = pickup.attr; pickups[i * 5 + 1] = (byte)((pickup.y << 5) | (pickup.x & 0x1f)); pickups[i * 5 + 2] = (byte)(pickup.y >> 3); } else { pickups[i * 5 + 0] = 0; } } _rom.WriteBytes(WriteKind.SerialisedRom, _pickupOffset, pickups); } private IWidgetLabel _itemCounter; public void SetItemCounterWidget(IWidgetLabel widget) { _itemCounter = widget; UpdateItemCount(); } void DeletePickup(byte x, byte y) { for (int i=0;i<_pickups.Count;i++) { if (_pickups[i].x == x && _pickups[i].y == y) { _pickups.RemoveAt(i); UpdateItemCount(); return; } } } // Valid colours are magenta=3, green=4, cyan=5, yellow=6 - for now just cycle it based on count private static readonly byte[] _pickupAttributes = new byte[] { 3, 4, 5, 6 }; bool AddPickup(byte x, byte y) { if (_pickups.Count >= 5) { return false; } var pickupAttr = _pickupAttributes[_pickups.Count & 3]; _pickups.Add(new Pickup { x = x, y = y, attr = pickupAttr }); UpdateItemCount(); return true; } void UpdateItemCount() { if (_itemCounter != null) { _itemCounter.Name = $\"Items: {_pickups.Count} / 5\"; } } public ReadOnlySpan<uint> GetMapData() { return mapData; } public void SetTile(uint x, uint y, uint tile) { // If we overwrite a pickup, we need to update the pickup data if (mapData[y*Width+x]==8) { // Remove pickup from pickup data DeletePickup((byte)x, (byte)y); } // If we are adding a pickup, we need to update the pickup data if (tile == 8) { // Add pickup to pickup data if (!AddPickup((byte)x, (byte)y)) { // Failed to add pickup - too many pickups in use return; } } else { // Regular tile, just update the map data _rom.WriteBytes(WriteKind.SerialisedRom, 0x4000 * 6 + 0 + y * Width + x, new byte[] { _tilePalette.IndexToAttr(tile) }); } StorePickups(); // Update the pickup data mapData[y * Width + x] = tile; } } class ManicMinerTileMap : ITileMap { public uint Width => 32 * 8; public uint Height => 16 * 8; public uint NumLayers => 1; public float ScaleX => 2.0f; public float ScaleY => 2.0f; private TilePaletteStore _tilePaletteStore; private ManicMinerTileMapLayer _layer; public ManicMinerTileMap(IMemoryAccess rom, uint offset, ManicMinerTilePalette tilePalette) { _tilePaletteStore = tilePalette.tilePaletteStore; _layer = new ManicMinerTileMapLayer(rom, offset, tilePalette); } public void SetItemCounterWidget(IWidgetLabel widget) { _layer.SetItemCounterWidget(widget); } public ILayer FetchLayer(uint layer) { return _layer; } public TilePaletteStore FetchPalette(uint layer) { return _tilePaletteStore; } } class ManicMinerTileEditor : IUserWindow { public float UpdateInterval => 1 / 30.0f; private ManicMinerTilePalette tilePalette; private ManicMinerTileMap tileMap; public ManicMinerTileEditor(IMemoryAccess rom) { tilePalette = new ManicMinerTilePalette(rom); tileMap = new ManicMinerTileMap(rom, 0x4000 * 6 + 0, tilePalette); } public void ConfigureWidgets(IMemoryAccess rom, IWidget widget, IPlayerControls playerControls) { widget.AddLabel(\"Palette\"); widget.AddTilePaletteWidget(tilePalette.tilePaletteStore); tileMap.SetItemCounterWidget(widget.AddLabel(\"Items: 0 / 5\")); widget.AddLabel(\"TileMap\"); widget.AddTileMapWidget(tileMap); } public void OnClose() { // Do nothing for now } } The way this works; is we detect if a pickup is added or deleted on the tile map, and adjust the list of pickups each time (see ManicMinerTileMapLayer::SetTile). For convenience, we convert the tilemap data from the rom format into a local array (see ManicMinerTileMapLayer::GetPickups()) and back to rom format as required. A label widget is used to show a counter of how many items can be placed. At this point, I have a challenge - Can you update the code so that you can edit any of the 20 levels? to be continued under construction"
  },
  "docs/user-guide.html": {
    "href": "docs/user-guide.html",
    "title": "User Guide | RetroEditor",
    "keywords": "User Guide under construction Quick Start Upon running the RetroEditorApplication, you will currently be presented with a blank screen and a menu bar. The first thing to do is create a project, File->Create New Project. From here, click on Choose Game and select a supported game image. see under construction Alter the project name if you wish, then click on Create Project. After a short while (the libretro plugin to support the game needs to be downloaded), and the emulator should show the game. At this point the Window menu should have a new item (name of the project with a [1] appended to it), and this should expand to allow selection of various aspects to edit on the chosen game. under construction"
  },
  "index.html": {
    "href": "index.html",
    "title": "Retro Editor Documentation Portal | RetroEditor",
    "keywords": "Retro Editor Documentation Portal Retro Editor is an attempt to create a multi game modding tool, for any libRetro emulated system. Plugins are distributed in source form, and are compiled by the editor on startup. This allows the development of plugins independant of the main editor application. User Guide If you are here because you want to use the editor to edit a game using an existing plugin, then follow this link : User Guide. Developer Guide If you want to develop a plugin or modify an existing plugin, the follow this link : Developer Guide Editor Developer Guide under construction"
  }
}